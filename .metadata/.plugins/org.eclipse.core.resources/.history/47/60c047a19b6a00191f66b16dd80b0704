package interview1;
import java.util.*;
/* Key = Any Data
 * Hash Table = Map Data to hash values i.e. ints or longs
 * 1st -> Compute Data's Hash code -> Hash code not unique to one Key
 * 2nd -> Map the Hash code to index in array. Can map two codes to same index
 * 3rd -> At index -> Linked List of Keys and Values.
 * Runtime -> Good Implementation - O(1). Worst Case - O(N)
 * Alternatively -> Hash Table can be a Balanced BST -> Runtime O(logN)
 */
public class HashTable {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

	
/*
 * merge = double array list
 * runtime = O(N) but happens so rarely that amoritized is O(1)
 */
ArrayList<String> merge(String[] words, String[] more){
	ArrayList<String> sentence = new ArrayList<String>();
	for(String w : words) sentence.add(w);
	for(String w:more) sentence.add(w);
	return sentence;
}
/*
 * sConcatanator = joins words together in a string
 * runtime = O(n^2) because Sigma(1 to n) = n(n+1)/2 = n^2(x) or O(n^2)
 */
String sConcatanator(String[] words) {
	String sentence = "";
	
	for(String w : words) sentence += w;
	
	return sentence;
}
/*
 * string builder - better for concatanating
 * runtime = O(n) worst case, best O(1)
 */

String joinWords(String[] words) {
	StringBuilder sentence = new StringBuilder();
	for(String w : words) sentence.append(w);
	
	return sentence.toString();
	
}

boolean isUnique(String word) {
	if(word.length() == 0) return false;
	char[] charArray = word.toCharArray();
	for(int i = 0; i < word.length()/2; i++) {
		for(int j = 0; j < word.length(); j++) {
			if(charArray[i] == charArray[j]) return false;
		}
	}
	return true;
}
	
}
